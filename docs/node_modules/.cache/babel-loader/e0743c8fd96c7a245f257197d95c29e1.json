{"ast":null,"code":"var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])'];\nvar candidateSelector = candidateSelectors.join(',');\nvar matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n  var elementDocument = el.ownerDocument || el;\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  var untouchabilityChecker = new UntouchabilityChecker(elementDocument);\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n    if (!isNodeMatchingSelectorTabbable(candidate, untouchabilityChecker)) continue;\n    candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {\n    return a.node;\n  }).concat(regularTabbables);\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node, untouchabilityChecker) {\n  if (!isNodeMatchingSelectorFocusable(node, untouchabilityChecker) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTabbable(node, untouchabilityChecker) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node, untouchabilityChecker);\n}\n\nfunction isNodeMatchingSelectorFocusable(node, untouchabilityChecker) {\n  untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker(node.ownerDocument || node);\n\n  if (node.disabled || isHiddenInput(node) || untouchabilityChecker.isUntouchable(node)) {\n    return false;\n  }\n\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\n\nfunction isFocusable(node, untouchabilityChecker) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node, untouchabilityChecker);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n} // Array.prototype.find not available in IE.\n\n\nfunction find(list, predicate) {\n  for (var i = 0, length = list.length; i < length; i++) {\n    if (predicate(list[i])) return list[i];\n  }\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true; // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n} // An element is \"untouchable\" if *it or one of its ancestors* has\n// `visibility: hidden` or `display: none`.\n\n\nfunction UntouchabilityChecker(elementDocument) {\n  this.doc = elementDocument; // Node cache must be refreshed on every check, in case\n  // the content of the element has changed. The cache contains tuples\n  // mapping nodes to their boolean result.\n\n  this.cache = [];\n} // getComputedStyle accurately reflects `visibility: hidden` of ancestors\n// but not `display: none`, so we need to recursively check parents.\n\n\nUntouchabilityChecker.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {\n  if (node.nodeType !== Node.ELEMENT_NODE) return false; // Search for a cached result.\n\n  var cached = find(this.cache, function (item) {\n    return item === node;\n  });\n  if (cached) return cached[1];\n  nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);\n  var result = false;\n\n  if (nodeComputedStyle.display === 'none') {\n    result = true;\n  } else if (node.parentNode) {\n    result = this.hasDisplayNone(node.parentNode);\n  }\n\n  this.cache.push([node, result]);\n  return result;\n};\n\nUntouchabilityChecker.prototype.isUntouchable = function isUntouchable(node) {\n  if (node === this.doc.documentElement) return false;\n  var computedStyle = this.doc.defaultView.getComputedStyle(node);\n  if (this.hasDisplayNone(node, computedStyle)) return true;\n  return computedStyle.visibility === 'hidden';\n};\n\nmodule.exports = tabbable;","map":{"version":3,"sources":["/Users/khadijaal-selini/call-for-code/policy-truth-frontend/node_modules/tabbable/index.js"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","tabbable","el","options","elementDocument","ownerDocument","regularTabbables","orderedTabbables","untouchabilityChecker","UntouchabilityChecker","candidates","querySelectorAll","includeContainer","call","Array","slice","apply","unshift","i","candidate","candidateTabindex","length","isNodeMatchingSelectorTabbable","getTabindex","push","documentOrder","tabIndex","node","tabbableNodes","sort","sortOrderedTabbables","map","a","concat","isTabbable","isFocusable","isNodeMatchingSelectorFocusable","isNonTabbableRadio","Error","disabled","isHiddenInput","isUntouchable","focusableCandidateSelector","tabindexAttr","parseInt","getAttribute","isNaN","isContentEditable","b","find","list","predicate","contentEditable","isInput","tagName","type","isRadio","isTabbableRadio","getCheckedRadio","nodes","checked","name","radioSet","doc","cache","hasDisplayNone","nodeComputedStyle","nodeType","Node","ELEMENT_NODE","cached","item","defaultView","getComputedStyle","result","display","parentNode","documentElement","computedStyle","visibility","module","exports"],"mappings":"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","sourcesContent":["var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var elementDocument = el.ownerDocument || el;\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var untouchabilityChecker = new UntouchabilityChecker(elementDocument);\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate, untouchabilityChecker)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node, untouchabilityChecker) {\n  if (\n    !isNodeMatchingSelectorFocusable(node, untouchabilityChecker)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node, untouchabilityChecker) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node, untouchabilityChecker);\n}\n\nfunction isNodeMatchingSelectorFocusable(node, untouchabilityChecker) {\n  untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker(node.ownerDocument || node);\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || untouchabilityChecker.isUntouchable(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node, untouchabilityChecker) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node, untouchabilityChecker);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\n// Array.prototype.find not available in IE.\nfunction find(list, predicate) {\n  for (var i = 0, length = list.length; i < length; i++) {\n    if (predicate(list[i])) return list[i];\n  }\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\n// An element is \"untouchable\" if *it or one of its ancestors* has\n// `visibility: hidden` or `display: none`.\nfunction UntouchabilityChecker(elementDocument) {\n  this.doc = elementDocument;\n  // Node cache must be refreshed on every check, in case\n  // the content of the element has changed. The cache contains tuples\n  // mapping nodes to their boolean result.\n  this.cache = [];\n}\n\n// getComputedStyle accurately reflects `visibility: hidden` of ancestors\n// but not `display: none`, so we need to recursively check parents.\nUntouchabilityChecker.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {\n  if (node.nodeType !== Node.ELEMENT_NODE) return false;\n\n    // Search for a cached result.\n    var cached = find(this.cache, function(item) {\n      return item === node;\n    });\n    if (cached) return cached[1];\n\n    nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);\n\n    var result = false;\n\n    if (nodeComputedStyle.display === 'none') {\n      result = true;\n    } else if (node.parentNode) {\n      result = this.hasDisplayNone(node.parentNode);\n    }\n\n    this.cache.push([node, result]);\n\n    return result;\n}\n\nUntouchabilityChecker.prototype.isUntouchable = function isUntouchable(node) {\n  if (node === this.doc.documentElement) return false;\n  var computedStyle = this.doc.defaultView.getComputedStyle(node);\n  if (this.hasDisplayNone(node, computedStyle)) return true;\n  return computedStyle.visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n"]},"metadata":{},"sourceType":"script"}